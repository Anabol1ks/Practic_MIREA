### **Объяснение метода Хука-Дживса**

Метод **Хука-Дживса** (Hooke-Jeeves) — это один из методов нулевого порядка для минимизации функций, то есть он не использует производные целевой функции, а только её значения в различных точках. Этот метод относится к категории **поисковых методов без градиента** и использует две ключевые стратегии поиска:

1. **Эксплоративный (исследовательский) поиск (Exploratory Search)**  
   На каждом шаге выполняется исследование окрестности текущей точки по координатным направлениям (по оси X и по оси Y) с фиксированным шагом. Если найдена точка с меньшим значением функции, она принимается за новую лучшую точку.

2. **Шаблонное перемещение (Pattern Move)**  
   Если во время эксплоративного поиска найдено улучшение, делается попытка ускорить процесс, переместив точку в направлении улучшения. Это движение выполняется относительно предыдущей лучшей точки.

Алгоритм можно описать следующим образом:

1. Выбираем **начальную точку** \((x_0, y_0)\) и **начальный шаг** \(step\).
2. Выполняем **исследовательский поиск** в окрестности текущей точки.
3. Если найдено улучшение, выполняем **шаблонное перемещение**.
4. Повторяем процесс, пока шаг \( step \) не станет меньше заданного порога \( tol \).
5. Если улучшений нет, уменьшаем шаг вдвое.
6. Продолжаем до достижения заданной точности или превышения максимального числа итераций.

Метод Хука-Дживса балансирует между точностью поиска и эффективностью, сокращая число вычислений целевой функции по сравнению с полным перебором.

---

### **Объяснение кода**
#### **1. Функция для вычисления целевой функции**
```go
func f(x, y float64) float64 {
	return x*x + x*y + y*y + 2*x + 3*y
}
```
Здесь задана функция, которую нужно минимизировать:
\[
f(x, y) = x^2 + xy + y^2 + 2x + 3y
\]
Она принимает два аргумента \( x \) и \( y \) и возвращает их значение.

---

#### **2. Эксплоративный поиск**
```go
func exploratorySearch(x, y, step float64) (float64, float64) {
	bestX, bestY := x, y
	bestVal := f(x, y)

	// Поиск по оси X
	trialX := bestX + step
	trialVal := f(trialX, bestY)
	if trialVal < bestVal {
		bestX = trialX
		bestVal = trialVal
	} else {
		trialX = bestX - step
		trialVal = f(trialX, bestY)
		if trialVal < bestVal {
			bestX = trialX
			bestVal = trialVal
		}
	}

	// Поиск по оси Y
	trialY := bestY + step
	trialVal = f(bestX, trialY)
	if trialVal < bestVal {
		bestY = trialY
		bestVal = trialVal
	} else {
		trialY = bestY - step
		trialVal = f(bestX, trialY)
		if trialVal < bestVal {
			bestY = trialY
			bestVal = trialVal
		}
	}

	return bestX, bestY
}
```
Эта функция выполняет **исследовательский поиск** (Exploratory Search) в окрестности текущей точки. Она:
- Пробует сместить текущую точку в положительном и отрицательном направлении по оси \( X \).
- Если улучшение не найдено, пробует по оси \( Y \).
- Если найдено улучшение, новая точка фиксируется как лучшая.

---

#### **3. Реализация метода Хука-Дживса**
```go
func hookeJeeves(initialX, initialY, step, tol float64, maxIter int) (float64, float64, float64) {
	baseX, baseY := initialX, initialY
	newX, newY := initialX, initialY
	iter := 0

	for step > tol && iter < maxIter {
		fmt.Printf("Итерация %d:\n", iter)
		fmt.Printf("  Базовая точка: (%.6f, %.6f)  f = %.6f\n", baseX, baseY, f(baseX, baseY))
		fmt.Printf("  Текущая точка: (%.6f, %.6f)  f = %.6f\n", newX, newY, f(newX, newY))
		fmt.Printf("  Размер шага: %.6f\n", step)

		// Исследовательский поиск
		xExpl, yExpl := exploratorySearch(newX, newY, step)
		fmt.Printf("  Предварительный результат поиска: (%.6f, %.6f)  f = %.6f\n", xExpl, yExpl, f(xExpl, yExpl))

		// Если улучшения нет, уменьшаем шаг
		if f(xExpl, yExpl) >= f(newX, newY) {
			fmt.Println("  Улучшений не обнаружено. Шаг сокращения.")
			step = step / 2.0
		} else {
			// Шаблонное перемещение
			patternX := xExpl + (xExpl - baseX)
			patternY := yExpl + (yExpl - baseY)
			fmt.Printf("  Шаблон перемещения кандидата: (%.6f, %.6f)\n", patternX, patternY)
			newPatternX, newPatternY := exploratorySearch(patternX, patternY, step)
			fmt.Printf("  Результат после поискового перемещения по шаблону: (%.6f, %.6f)  f = %.6f\n", newPatternX, newPatternY, f(newPatternX, newPatternY))

			// Обновляем точки
			baseX, baseY = xExpl, yExpl
			newX, newY = newPatternX, newPatternY
		}

		fmt.Println("-----------------------------------------------------")
		iter++
	}
	return newX, newY, f(newX, newY)
}
```
**Что здесь происходит?**
1. **Основной цикл**: Выполняется, пока шаг \( step \) больше \( tol \) и не превышено количество итераций.
2. **Вывод текущей информации**: Номер итерации, базовая точка, текущая точка и значение функции.
3. **Выполняется исследовательский поиск** в окрестности текущей точки.
4. **Если улучшение не найдено**, шаг уменьшается вдвое.
5. **Если улучшение найдено**, выполняется **шаблонное перемещение** в направлении улучшения.
6. **Обновляются точки**, и процесс повторяется.

---

#### **4. Запуск алгоритма**
```go
func main() {
	initialX := 0.0
	initialY := 0.0
	step := 1.0
	tol := 1e-6
	maxIter := 10000

	bestX, bestY, bestVal := hookeJeeves(initialX, initialY, step, tol, maxIter)
	fmt.Printf("Найденный минимум методом Хука-Дживса:\n")
	fmt.Printf("  x = %.6f, y = %.6f, f(x,y) = %.6f\n", bestX, bestY, bestVal)
}
```
Здесь задаются начальные параметры и вызывается метод **Хука-Дживса**. После завершения работы выводится **найденный минимум**.

---

### **Вывод**
Этот алгоритм успешно минимизирует функцию методом Хука-Дживса. Он использует комбинацию **исследовательского поиска** и **шаблонного перемещения**, чтобы ускорить поиск минимума, а затем уменьшает шаг, когда улучшения перестают находиться.